# Assembly generation
## Introduction

На этот раз мы добрались до определённой вехи: наконец-то будем генерировать не питоновский код, а ассемблерный.
Работу со стеком и регистрами, которые доставляют наибольшее количество проблем новичкам в ассемблере, мы разобрали в предыдущей статье, так что на этот раз осталось всего ничего.
На данный момент наш компилятор генерирует питоновский код, структура которого полностью соответствует желаемому ассемблерному.
Единственный момент, с которым осталось разобраться — это с выводом на экран, всё остальное уже решительно готово.

## Hello world, или вывод строк на экран

Чаще всего в учебных компиляторах выбирают ассемблер MIPS, но мне не нравится запускать код в эмуляторе, поэтому я недолго думал, и выбрал x86 GNU ассемблер, благо, он идёт в составе gcc.
Не могу точно сказать почему, но захотелось мне 32-битную версию.
Для наших целей совершенно ни к чему быть ассемблерным гуру, но программы уровня хелловорлд писать надо уметь.

Давайте сделаем заготовку, от которой будем впоследствии отталкиваться.
Представим, что у нас есть файл [helloworld.s](assembly/helloworld.s) со следующим содержимым:

```asm linenums="1"
--8<-- "assembly/helloworld.s"
```

Тогда мы его можем скомпилировать при помощи команд as и ld следующим образом:

```
as --march=i386 --32 -o helloworld.o helloworld.s &&
ld -m elf_i386 helloworld.o -o helloworld &&
./helloworld
```

Если всё пошло хорошо, то на экране должно красоваться гордое приветствие.
Теперь давайте разбираться, что же там происходит.
А там только два системных вызова — `sys_write` и `sys_exit`.
На сях то же самое можно было бы написать следующим образом:

```cpp
#include <sys/syscall.h>
#include <unistd.h>

int main(void) {
        syscall(SYS_write, 1, "hello world\n", 12);
        return 0;
}
```

Если звёзды правильно сойдутся, то gcc сгенерирует примерно такой же ассемблерный код.
Для наших нужд никаких других системных вызовов больше не нужно, `write` и `exit` нам хватит за глаза, ведь единственное взаимодействие с внешним миром в wend — это вывод на экран.

Wend не умеет никаких операций со строками, только вывод константных строк на экран, поэтому мой компилятор для каждой строки просто создаёт в заголовке уникальный идентификатор ровно как для нашего hello world.
Для вывода на экран булевых значений две константные строки `true` и `false`.
А что с числами? А вот тут придётся чуть‑чуть поработать.
Я лентяй, и мне неохота было разбираться с линковкой glibc и тому подобного, поэтому роскошь `printf` мне недоступна.
Ну и ладно, мы и с `sys_write` управимся :)

# Вывод на экран десятичных чисел

`sys_write` умеет выводить на экран строки, поэтому нам надо научиться конвертировать числа (у меня только знаковые 32-битные) в строковое представление.
Для этого я закатал рукава и написал функцию [`print_int32`](assembly/print_int32.s):

```asm linenums="1"
--8<-- "assembly/print_int32.s"
```

Чужой ассемблерный код читать непросто, поэтому давайте я приведу [питоновский эквивалент](assembly/print_int32.py) нашей функции:

```py linenums="1"
--8<-- "assembly/print_int32.py"
```

`write` я буду вызывать только один раз, поэтому нужно подготовить строковый буфер.
32-битное число не потребует больше 11 символов, поэтому я выделяю 16 под буфер (чтобы стек был выровнен по краю машинного слова).
Затем конвертирую в строку модуль заданного числа, и в конце приклеиваю минус, если число было отрицательным.

При помощи такой нехитрой гимнастики мы можем выводить на экран строки и числа, и, что характерно, без головной боли линковки с какой-нибудь 32-битной версией libc на 64-битной системе.

А такой вывод на экран необходим не только для поддержки инструкции `print` нашего языка, но и для отладки.
GDB это для слабых духом, вставка вывода на экран где ни попадя — это наше всё ;)

# Собираем всё вместе
Ну, собственно, и всё.
Теперь берём шаблон генерации питоновского кода, и вместо вывода питоновского `print()` достаточно написать `call print_int32`, вместо `eax = eax * ebx` написать `imull %ebx, %eax`.
Таким образом планомерно переводим питоновские инструкции в ассемблерные, и дело в шляпе! Никаких тонкостей не осталось, долгожданный компилятор почти готов.
Можно взять [релиз v0.0.5](https://github.com/ssloy/tinycompiler/releases/tag/v0.0.5) и с ним поиграть.

Промежуточная цель достигнута: мы научились компилировать собственный язык в настоящий x86 GNU ассемблер.
На данный момент для парсинга я пользуюсь сторонней библиотекой sly, но по пути меня слегка занесло, и выяснилось, что написать свой парсер совсем несложно.
А заодно можно будет грамматику языка подправить, чтобы приятнее писать можно было!

Таким образом, следующие две статьи будут о том, как самостоятельно сделать лексер и парсер, [готовый код уже лежит в репозитории](https://github.com/ssloy/tinycompiler).




